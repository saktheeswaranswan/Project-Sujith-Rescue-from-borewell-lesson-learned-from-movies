// Slope Rescue — draggable rescuers that pull the rope along the slope
// Paste into p5.js web editor (or an index.html that loads p5.js)

let rescuerCount = 8;
let rescuers = [];
let slopeAngle;             // set inside setup()
let slopeLength = 700;
let slopeBaseX, slopeBaseY;
let pulleyPos;
let man;
let gravity = 9.8;         // m/s^2 (visual/scaled)
let timeStep = 1 / 60;
let pulling = false;       // used by Start/Stop (force-driven mode)
let startButton, stopButton, randomButton;
let inputBoxes = [];
let frictionCoefficient = 0.3;
let showForces = true;
let successTimer = 0;      // frames to show success overlay

// Rope / pull state (px units)
let ropeVerticalLength;    // length from pulley groove to man top (px)
let ropeMinLength;         // when man at rim
let ropeMaxLength;         // when man at bottom
let ropeTotalPulled = 0;   // cumulative pulled length (px) taken from slope into vertical
let ropeMaxPullable;       // ropeTotalPulled max = ropeMaxLength - ropeMinLength
let ropeVisualProgress = 0;

// dragging
let draggingIndex = -1;
let dragRadius = 24;

function setup() {
  createCanvas(1100, 700);
  frameRate(60);

  slopeAngle = radians(30);
  slopeBaseX = 150;
  slopeBaseY = height - 80;
  pulleyPos = createVector(
    slopeBaseX + cos(slopeAngle) * slopeLength,
    slopeBaseY - sin(slopeAngle) * slopeLength - 80
  );

  // create rescuers positioned along the slope (even spacing)
  rescuers = [];
  for (let i = 0; i < rescuerCount; i++) {
    // s = distance along slope from base (0..slopeLength)
    let s = (i + 0.5) / rescuerCount * (slopeLength * 0.6); // cluster lower half
    let pos = slopePointFromS(s);
    rescuers.push({
      s,                  // scalar distance along slope
      x: pos.x,
      y: pos.y,
      prevS: s,           // used for computing motion this frame
      force: 50,          // legacy force input (N)
      id: i + 1
    });
  }

  // man (in borewell)
  man = {
    mass: 80,          // kg
    yNorm: 0,          // 0 bottom -> 1 rim (visual)
    vel: 0
  };

  man.heightAtPulley = pulleyPos.y + 100;      // rim top y
  man.bottomDepth = pulleyPos.y + 380;         // bottom y

  // initialize rope vertical lengths
  ropeMaxLength = man.bottomDepth - (pulleyPos.y + 20);
  ropeMinLength = man.heightAtPulley - (pulleyPos.y + 20);
  ropeVerticalLength = ropeMaxLength; // starts at bottom
  ropeTotalPulled = 0;
  ropeMaxPullable = ropeMaxLength - ropeMinLength;

  // UI inputs (placed below the canvas)
  inputBoxes = [];
  for (let i = 0; i < rescuerCount; i++) {
    let inp = createInput(String(rescuers[i].force));
    inp.size(60, 22);
    let px = 20 + (i % 6) * 120;
    let py = height + 10 + floor(i / 6) * 34;
    inp.position(px, py);
    inputBoxes.push(inp);
  }

  // Buttons
  startButton = createButton("Start Pull (force-driven)");
  startButton.position(20, height + 90);
  startButton.mousePressed(() => {
    for (let i = 0; i < rescuerCount; i++) {
      let val = Number(inputBoxes[i].value());
      if (!isFinite(val)) val = 0;
      rescuers[i].force = max(0, val);
    }
    pulling = true;
  });

  stopButton = createButton("Stop");
  stopButton.position(260, height + 90);
  stopButton.mousePressed(() => (pulling = false));

  randomButton = createButton("Randomize Forces");
  randomButton.position(340, height + 90);
  randomButton.mousePressed(() => {
    for (let i = 0; i < rescuers.length; i++) {
      let r = floor(random(10, 110));
      rescuers[i].force = r;
      inputBoxes[i].value(String(r));
    }
  });

  createP("Toggle force vectors: press 'f' — Drag rescuers' hands along the slope to pull rope.").position(420, height + 80);
}

function draw() {
  background(220);

  // scenery and slope
  drawScenery();

  // slope line
  stroke(80);
  strokeWeight(3);
  line(
    slopeBaseX,
    slopeBaseY,
    slopeBaseX + cos(slopeAngle) * slopeLength,
    slopeBaseY - sin(slopeAngle) * slopeLength
  );

  // rope/pulley/man visuals
  drawPulleyAndRope();

  // rescuers (update screen x,y from s)
  for (let r of rescuers) {
    let p = slopePointFromS(r.s);
    r.x = p.x;
    r.y = p.y;
    drawRescuer(r);
  }

  // man and HUD
  drawMan();

  // if force-driven pulling is turned on, let that mechanism also shorten rope
  if (pulling) simulateForceDrivenPull();

  // dragging-driven pull: compute movement since last frame and add to ropeTotalPulled
  handleRescuerMotionPulling();

  // update man vertical rope -> yNorm mapping
  updateManFromRope();

  // HUD text
  noStroke();
  fill(0);
  textSize(14);
  textAlign(LEFT);
  text("Slope Rescue — drag rescuers up the slope to pull rope and lift the man", 20, 22);
  text(`Slope angle: ${degrees(slopeAngle).toFixed(1)}°`, 20, 42);
  text(`Total team members: ${rescuerCount}`, 20, 60);

  let totalPull = computeTotalTension();
  let manWeight = man.mass * gravity;
  text(`Total effective team pull (force-mode): ${totalPull.toFixed(1)} N`, 20, 90);
  text(`Man weight: ${manWeight.toFixed(1)} N`, 20, 110);
  text(`Man height: ${(man.yNorm * 100).toFixed(1)} % (0=deep,100=rim)`, 20, 130);

  // success overlay if rescued
  if (successTimer > 0) {
    push();
    fill(0, 180, 60, 200);
    rect(0, 0, width, height);
    fill(255);
    textSize(48);
    textAlign(CENTER, CENTER);
    text("RESCUED! — MAN IS SAFE", width / 2, height / 2);
    pop();
    successTimer--;
  }
}

// ------------------ required scenery function ------------------
function drawScenery() {
  // sky
  noStroke();
  fill(150, 200, 255);
  rect(0, 0, width, height * 0.6);

  // distant mountains
  fill(120, 130, 140);
  triangle(0, height * 0.6, 180, 120, 360, height * 0.6);
  triangle(260, height * 0.6, 500, 80, 740, height * 0.6);
  triangle(640, height * 0.6, 860, 140, 1030, height * 0.6);

  // rocky slope texture (rotate canvas to draw strokes along slope)
  push();
  translate(slopeBaseX, slopeBaseY);
  rotate(-slopeAngle);
  for (let i = 0; i < slopeLength; i += 22) {
    stroke(110, 90, 60);
    line(i, 0, i + random(-6, 6), -random(10, 50));
  }
  pop();
}

// --------- helpers ----------

function slopePointFromS(s) {
  // s is distance along slope from slopeBase (0..slopeLength)
  let ux = cos(slopeAngle);
  let uy = -sin(slopeAngle);
  return {
    x: slopeBaseX + ux * s,
    y: slopeBaseY + uy * s
  };
}

function sFromPoint(px, py) {
  // Project point onto slope vector and return scalar s
  let vx = px - slopeBaseX;
  let vy = py - slopeBaseY;
  let ux = cos(slopeAngle);
  let uy = -sin(slopeAngle);
  let s = vx * ux + vy * uy; // dot product
  return constrain(s, 0, slopeLength);
}

// draw rescuer including hand circle used for dragging
function drawRescuer(r) {
  // stick figure (slightly offset so hand is near rope)
  push();
  translate(r.x, r.y);
  stroke(200, 30, 30);
  strokeWeight(2);
  fill(230, 80, 80);
  ellipse(0, -28, 24, 24); // head
  line(0, -16, 0, 6); // body
  line(0, -6, -10, 18); // left leg
  line(0, -6, 10, 18); // right leg
  // arm pointing roughly toward pulley
  let armX = 18;
  let armY = -18;
  line(0, -20, armX, armY);
  pop();

  // hand position (where rope attaches) - small offset from body
  let hand = createVector(r.x + 18, r.y - 18);
  noStroke();
  fill(80);
  ellipse(hand.x, hand.y, 10, 10);

  // index
  noStroke();
  fill(0);
  textSize(12);
  textAlign(CENTER);
  text(r.id, r.x, r.y - 44);

  // force arrow towards pulley (legacy force-mode visualization)
  if (showForces) {
    let from = createVector(r.x, r.y - 14);
    let to = pulleyPos.copy();
    let dir = p5.Vector.sub(to, from);
    let dirUnit = dir.copy().normalize();
    let mag = r.force;
    let drawLen = map(mag, 0, 120, 0, 110);

    let blink = (!pulling) || (frameCount % 30 < 18);
    if (mag > 0 && blink) {
      stroke(200, 30, 30);
      strokeWeight(2.2);
      let tip = p5.Vector.add(from, p5.Vector.mult(dirUnit, drawLen));
      line(from.x, from.y, tip.x, tip.y);
      let perp = createVector(-dirUnit.y, dirUnit.x);
      let base = p5.Vector.sub(tip, p5.Vector.mult(dirUnit, 8));
      let left = p5.Vector.add(base, p5.Vector.mult(perp, 6));
      let right = p5.Vector.sub(base, p5.Vector.mult(perp, 6));
      line(tip.x, tip.y, left.x, left.y);
      line(tip.x, tip.y, right.x, right.y);
    }

    // label magnitude
    noStroke();
    fill(0);
    textSize(11);
    textAlign(LEFT);
    text(`${mag.toFixed(0)} N`, r.x + 12, r.y - 8);
  }
}

function drawPulleyAndRope() {
  // pulley
  fill(180);
  stroke(60);
  strokeWeight(2);
  ellipse(pulleyPos.x, pulleyPos.y, 48, 48);

  // rope from each rescuer to pulley
  stroke(90, 50, 20);
  strokeWeight(2);
  for (let r of rescuers) {
    let hand = createVector(r.x + 18, r.y - 18);
    line(hand.x, hand.y, pulleyPos.x, pulleyPos.y);
  }

  // vertical rope from pulley down to manTop
  strokeWeight(4);
  let manTopY = pulleyPos.y + 20 + ropeVerticalLength;
  line(pulleyPos.x, pulleyPos.y + 20, pulleyPos.x, manTopY);

  // small marker on slope showing rope pulled-in amount
  ropeVisualProgress = constrain(map(ropeTotalPulled, 0, ropeMaxPullable, 0, slopeLength), 0, slopeLength);
  let ropeMarkerX = slopeBaseX + cos(slopeAngle) * ropeVisualProgress;
  let ropeMarkerY = slopeBaseY - sin(slopeAngle) * ropeVisualProgress;
  push();
  fill(40, 120, 200);
  noStroke();
  ellipse(ropeMarkerX, ropeMarkerY - 8, 12, 12);
  pop();

  // visual thicker short rope segment from marker toward pulley
  push();
  stroke(60, 40, 20);
  strokeWeight(3);
  let segStart = createVector(ropeMarkerX, ropeMarkerY);
  line(segStart.x, segStart.y, pulleyPos.x, pulleyPos.y);
  pop();
}

function drawMan() {
  // compute actual man Y from ropeVerticalLength
  let manY = map(ropeVerticalLength, ropeMaxLength, ropeMinLength, man.bottomDepth, man.heightAtPulley);

  // borewell rim ellipse
  stroke(40);
  strokeWeight(2);
  noFill();
  ellipse(pulleyPos.x, man.heightAtPulley + 30, 120, 40);

  // shaft
  fill(30);
  noStroke();
  rect(pulleyPos.x - 60, man.heightAtPulley + 30, 120, man.bottomDepth - man.heightAtPulley + 60);

  // inner top shading
  push();
  translate(pulleyPos.x, man.heightAtPulley + 30);
  fill(20);
  ellipse(0, 0, 120, 40);
  pop();

  // man body
  push();
  translate(pulleyPos.x, manY);
  stroke(90, 50, 20);
  strokeWeight(2);
  line(0, -24, 0, -6);
  fill(150, 40, 40);
  ellipse(0, 10, 30, 30);
  line(0, 25, 0, 50);
  line(0, 40, -10, 60);
  line(0, 40, 10, 60);
  pop();

  // label & status
  noStroke();
  fill(255);
  textAlign(CENTER);
  textSize(12);
  text("BOREWELL", pulleyPos.x, man.bottomDepth + 120);

  noStroke();
  fill(0);
  textSize(14);
  textAlign(CENTER);
  if (!pulling) {
    text("Pull paused (or drag rescuers to pull)", pulleyPos.x, man.bottomDepth + 20);
  } else {
    let totalPull = computeTotalTension();
    let net = totalPull - man.mass * gravity - (frictionCoefficient * man.mass * gravity);
    text(`Net vertical force: ${net.toFixed(1)} N`, pulleyPos.x, man.bottomDepth + 20);
  }
}

// compute tension from force inputs (legacy force-driven mode)
function computeTotalTension() {
  let total = 0;
  for (let r of rescuers) total += r.force;
  let pulleyEfficiency = 0.92;
  return total * pulleyEfficiency;
}

// When Start Pull (force-driven) is active, we translate net force to rope shortening
function simulateForceDrivenPull() {
  let totalTension = computeTotalTension();
  let weight = man.mass * gravity;
  let frictionLoss = frictionCoefficient * man.mass * gravity;
  let net = totalTension - weight - frictionLoss;

  // force->speed mapping tuned for visuals
  let forceToSpeed = 0.06; // px per (N*s)
  let deltaLength = 0;
  if (net > 0) deltaLength = -net * forceToSpeed * timeStep;
  else deltaLength = -net * 0.02 * timeStep; // slip

  // apply
  let prev = ropeVerticalLength;
  ropeVerticalLength = constrain(ropeVerticalLength + deltaLength, ropeMinLength, ropeMaxLength);
  // convert vertical shortening into pulled along slope (so visuals track)
  let pulledDelta = prev - ropeVerticalLength;
  ropeTotalPulled = constrain(ropeTotalPulled + pulledDelta, 0, ropeMaxPullable);
}

// This function measures per-rescuer s-change since previous frame and accumulates positive (upward) changes
// and negative (downward) changes to allow returning rope when rescuers move down.
function handleRescuerMotionPulling() {
  let totalPositiveDeltaS = 0;
  let totalNegativeDeltaS = 0;
  for (let r of rescuers) {
    let ds = r.s - r.prevS; // positive if moved toward pulley (up the slope)
    if (ds > 0) totalPositiveDeltaS += ds;
    else totalNegativeDeltaS += -ds;
    r.prevS = r.s;
  }

  if (totalPositiveDeltaS > 0) {
    // moving up the slope pulls rope from slope -> vertical (1:1 px mapping)
    ropeTotalPulled = constrain(ropeTotalPulled + totalPositiveDeltaS, 0, ropeMaxPullable);
  }

  if (totalNegativeDeltaS > 0) {
    // moving down the slope returns rope (unpulls) proportionally
    ropeTotalPulled = constrain(ropeTotalPulled - totalNegativeDeltaS, 0, ropeMaxPullable);
  }

  // update vertical rope accordingly
  ropeVerticalLength = constrain(ropeMaxLength - ropeTotalPulled, ropeMinLength, ropeMaxLength);
}

// Map rope position to man and simulate inertial feel / success
function updateManFromRope() {
  // map ropeVerticalLength to man.yNorm (0..1)
  let targetYNorm = map(ropeVerticalLength, ropeMaxLength, ropeMinLength, 0, 1);

  // smoothing to give inertia
  let stiffness = 8.0;
  let damping = 0.88;
  let error = targetYNorm - man.yNorm;
  let accel = stiffness * error;
  man.vel += accel * timeStep;
  man.vel *= damping;
  man.yNorm += man.vel * timeStep;

  man.yNorm = constrain(man.yNorm, 0, 1);

  if (man.yNorm >= 1) {
    man.yNorm = 1;
    successTimer = 180;
    // lock rope to rim
    ropeTotalPulled = ropeMaxPullable;
    ropeVerticalLength = ropeMinLength;
  }
  // synchronize ropeVerticalLength with man position (if physics pulls him)
  ropeVerticalLength = constrain(map(man.yNorm, 0, 1, ropeMaxLength, ropeMinLength), ropeMinLength, ropeMaxLength);
}

// ---------- mouse interaction for dragging rescuers ----------
function mousePressed() {
  // determine if mouse near any rescuer's hand
  for (let i = 0; i < rescuers.length; i++) {
    let r = rescuers[i];
    let hx = r.x + 18;
    let hy = r.y - 18;
    if (dist(mouseX, mouseY, hx, hy) <= dragRadius) {
      draggingIndex = i;
      return;
    }
  }
}

function mouseDragged() {
  if (draggingIndex >= 0) {
    // project mouse onto slope and update rescuer's s
    let s = sFromPoint(mouseX, mouseY);
    // clamp so rescuers don't pass the pulley or go below base
    s = constrain(s, 0, slopeLength);
    rescuers[draggingIndex].s = s;
  }
}

function mouseReleased() {
  draggingIndex = -1;
}

function keyPressed() {
  if (key === 'f' || key === 'F') showForces = !showForces;
}
